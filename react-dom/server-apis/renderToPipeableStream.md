**목차**

- [renderToPipeableStream](#rendertopipeablestream)
  - [레퍼런스](#레퍼런스)
  - [사용법](#사용법)
    - [빌드 출력에서 CSS 및 JS 에셋 경로 읽기](#빌드-출력에서-css-및-js-에셋-경로-읽기)
    - [콘텐츠가 로드되는 동안 더 많은 콘텐츠 스트리밍하기](#콘텐츠가-로드되는-동안-더-많은-콘텐츠-스트리밍하기)
    - [셸에 들어갈 내용 지정하기](#셸에-들어갈-내용-지정하기)
    - [셸 외부의 오류로부터 복구하기](#셸-외부의-오류로부터-복구하기)
    - [크롤러 및 정적 생성을 위해 모든 콘텐츠가 로드될 때까지 기다리기](#크롤러-및-정적-생성을-위해-모든-콘텐츠가-로드될-때까지-기다리기)

# renderToPipeableStream

1. > renderToPipeableStream은 React 트리를 파이프 가능한 Node.js 스트림으로 렌더링합니다.
   - https://elvanov.com/2670 요 블로그가 노드 스트림에 대해 좀 잘 설명해주고 있는 것 같아서 가져와봤습니다!
2. > 이 API는 Node.js 전용입니다. Deno 및 최신 엣지 런타임과 같은 Web 스트림이 있는 환경에서는 대신 renderToReadableStream을 사용해야 합니다.
   - Node.js 전용이라면 현재 리액트 서버사이드 렌더링은 자바스크립트로만 가능한 걸까요? 그러고보니 Next.js에서 띄워주는 서버도 Node.js로 구현할 걸까요?
   - Next.js에서는 Node.js 런타임과 Edge 런타임을 지원한다고 합니다. https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes
   - 적당히 deno nextjs로 찾아보니 deno, nextjs에서 서로를 지원한다 안한다로 논의가 있네요…! (현재는 안하고 있는 듯…)
   - 주변 개발자 동료들을 보면 [deno](https://deno.com)와 [bun](https://bun.sh)쪽도 나름의 팬덤(?)이 있는 것 같다...
   - 과거에 동료 개발자분이 next config에서 edge runtime option을 킨 채로 배포한 걸 본 적이 있다. vercel을 통해 배포할 때 serverless 함수 관련하여 cold start가 심하여 개선 목적으로 해당 옵션을 켜서 배포했었다.

## 레퍼런스

### renderToPipeableStream(reactNode, options?)

1. > renderToPipeableStream을 호출하여 React 트리를 HTML로 Node.js 스트림에 렌더링합니다.
   - 서버사이드 렌더링 리액트 프레임워크들을 뜯어보면 요런 서버 api들이 존재하겠군요..!
2. > [기본 휴리스틱에 대해 자세히 알아보세요.](https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225)
   - 공식문서가 나오기까지 이런 코드 상 주석이나 토론이 이루어졌을 걸 생각하면 흥미로워요 ㅎㅎ 이런 데 참여해서 실시간으로 보는 건 어떤 기분일지 😆

## 사용법

### 빌드 출력에서 CSS 및 JS 에셋 경로 읽기

1. > bootstrapScriptContent 옵션은 클라이언트에서 전역 window.assetMap 변수를 설정하는 추가 인라인 &lt;script&gt; 태그를 추가합니다. 이렇게 하면 클라이언트 코드가 동일한 assetMap을 읽을 수 있습니다:
   - 와 이렇게 해서 클라이언트와 서버가 동일한 에셋에 접근하도록 하는 거군요. 하이드레이션하는 분들은 정말 사용자 경험을 위해 코드를 깎으시는 것 같아요

### 콘텐츠가 로드되는 동안 더 많은 콘텐츠 스트리밍하기

1. > 이 예제에서 React는 페이지 스트리밍을 더 일찍 시작할 수 있습니다.
   - 예제랑 설명 보니까 갑자기 서스펜스 역할이 더 와닿는 것 같아요. 그냥 로딩 표시를 넣어준다고 생각했는데 실제로 서버에서 로딩 컴포넌트 HTML을 먼저 전송하는 거라고 하니까 이면에서 이루어지는 일이 좀 더 그려지는 것 같습니다!

### 셸에 들어갈 내용 지정하기

1. > 앱의 &lt;Suspense&gt; 경계 밖에 있는 부분을 셸이라고 합니다.
   - 파라미터 쪽에서 셸이라는 용어가 나와서 뭔가 싶어 당황했습니다 ㅎㅎ

### 셸 외부의 오류로부터 복구하기

1. > 셸 외부
   - 개인적인 생각인데 셸이 Suspense 바깥쪽으로 구성되는데 실제로 셸 내부는 Suspense의 부모 트리이고 셸 외부는 자식 트리다보니까 반대되는 단어라서 헷갈려요 ㅋㅋ
2. > Posts 컴포넌트 또는 그 내부 어딘가에서 오류가 발생하면 React는 이를 복구하려고 시도합니다. 가장 가까운 &lt;Suspense&gt; 경계(PostsGlimmer)에 대한 로딩 폴백을 HTML로 방출합니다. 더 이상 서버에서 Posts 콘텐츠를 렌더링하는 것을 “포기”합니다. 자바스크립트 코드가 클라이언트에서 로드되면 React는 클라이언트에서 Posts 렌더링을 재시도합니다.
   - 잘 감이 안 오는데 나중에 보면 또 다르지 않을까해서 킵해둡니다 ㅎㅎ

### 크롤러 및 정적 생성을 위해 모든 콘텐츠가 로드될 때까지 기다리기

1. > 크롤러 및 정적 생성을 위해 모든 콘텐츠가 로드될 때까지 기다리기 스트리밍은 콘텐츠가 제공될 때 바로 볼 수 있기 때문에 더 나은 사용자 경험을 제공합니다. 그러나 크롤러가 페이지를 방문하거나 빌드 시점에 페이지를 생성하는 경우 모든 콘텐츠를 점진적으로 표시하는 대신 모든 콘텐츠를 먼저 로드한 다음 최종 HTML 출력을 생성하는 것이 좋을 수 있습니다. onAllReady 콜백을 사용하여 모든 콘텐츠가 로드될 때까지 기다릴 수 있습니다.
   - 이런 가이드를 활용하면 SEO 접근성을 확보하기 위한 간단한 SSG는 직접 구현하는게 가능할 수 있겠다는 생각이 드네요 👀
   - 블로그같은걸 개인적으로 만들 때 시도해봐도 괜찮을 듯!
   - 카카오페이 기술블로그는 최근 gatsby에서 astro로 마이그레이션을 진행함 ([관련 포스팅](https://tech.kakaopay.com/post/kakaopay-techlog/))
2. > 일반 방문자는 점진적으로 로드되는 콘텐츠 스트림을 받게 됩니다. 크롤러는 모든 데이터가 로드된 후 최종 HTML 출력을 받게 됩니다.
   - 이 부분 보고 일반 방문자와 크롤러에게 다르게 보여줄 수 있다는 걸 처음 알아서 신기했어요! SEO를 너무 안 다뤄봐서 인지 😅
