# memo

**목차**

## 레퍼런스

### memo(Component, arePropsEqual?)

## 사용법

### props가 변경되지 않았을 때 리렌더링 건너뛰기

1. > memo는 객체 또는 렌더링 중에 정의된 일반 함수처럼 항상 다른 props가 컴포넌트에 전달되는 경우에 완전히 무용지물입니다. 따라서 memo와 함께 useMemo와 useCallback이 종종 필요합니다.

   - 이 부분은 몰랐던 내용이네요..! 여태 docs에서 봐온걸 떠올리면 당연한거지만 새삼..ㅎㅎㅎ

2. > 그렇다고 해서 크게 해가 되지 않기 때문에 일부 팀에서는 개별 사례에 대해 고려하지 않고 가능한 한 많이 memoize 하는 방식을 선택하기도 합니다.

   - 저도 과거엔 모든 컴포넌트를 다 memo로 둘렀던 것 같아요..ㅎㅎㅎㅎ
   - 저도 useCallback, useMemo 처음 알게 됐을 때 이렇게 좋은 게 있다니 하고 막 쓰다가 이게 맞나 싶었던 적이

3. > 장기적으로는 이 문제를 완전히 해결하기 위해 세분된 memoization를 자동으로 수행하는 방법을 연구하고 있습니다.

   - 오오오.. 이렇게 되면 정말 편하겠네요
   - 그러고보니 브라우저 엔진도 JIT 컴파일러 이런 걸로 최적화 해주는 거 보면 리액트도 점점 그렇게 가지 않을지

### state를 사용하여 memoization 된 컴포넌트 업데이트하기

### context를 사용하여 메모화된 컴포넌트 업데이트하기

### props 변경 최소화하기

1. > 때로는 개별 값도 자주 변경되지 않는 값으로 사용될 수 있습니다. 예를 들어 다음 컴포넌트는 값 자체가 아니라 값의 존재를 나타내는 불리언 값을 받습니다.

   - object를 받아서 내부에서 비교하지 않았나 잠깐 반성하면서 예제 킵해둡니다.
   - 객체를 무심코 넘긴 적이 많아서 ㅋㅋ

### 사용자 정의 비교 함수 지정하기

1. > 함수는 종종 부모 컴포넌트의 props와 state를 클로저로 다룹니다. oldProps.onClick !== newProps.onClick일 때 true를 반환하면 컴포넌트가 onClick 핸들러 내에서 이전 렌더링의 props와 state를 계속 “인식”하여 매우 혼란스러운 버그가 발생할 수 있습니다.

   - 클로저만 나오면 항상 어렵습니다. 일단 이전 props와 현재 props에서 함수가 다른 데 true를 반환해서 같다고 해버리면 혼란스러운 버그가 발생할 수 있다고 이해했어요. 근데 정말 구체적으로는 이해가 어렵네요 ㅎㅎ
   - 클로저가 함수 실행이 종료되도 변수에 여전히 접근 가능한 거 맞나요? 그러면 이전 함수를 없애지 않았을 때 이전 state와 props가 계속 참조되서 문제가 발생할 수 있다. 이렇게 이해하면 될까요?
   - 예를 들면 onClick 함수가 정의되는 게 렌더링할 때마다 바뀌는데 state가 1일 때 정의된 함수가 남아 있으면 실제 state가 2로 바뀌었을 때 문제가 될 수 있지 않을지

## 문제 해결

### prop가 객체, 배열 또는 함수인 경우 컴포넌트가 리렌더링됩니다.
